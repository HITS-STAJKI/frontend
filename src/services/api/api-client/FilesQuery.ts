//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
//@ts-nocheck
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './FilesClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type UploadFileFilesMutationParameters = {
  file?: Types.FileParameter | undefined;
}

export type GetFileMetadataFilesQueryParameters = {
  id: string;
}

export type DownloadFileFilesQueryParameters = {
  id: string;
}

export type GetMyFilesFilesQueryParameters = {
  page?: number | undefined;
  size?: number | undefined;
  sort?: string[] | undefined;
}

export type GetAllFilesByTypeFilesQueryParameters = {
  type: Types.Type;
  page?: number | undefined;
  size?: number | undefined;
  sort?: string[] | undefined;
}

export type DeleteFileFilesQueryParameters = {
  id: string;
}

export function uploadFileUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/files";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadFileMutationKey(): MutationKey {
  return trimArrayEnd([
    'FilesClient',
    'uploadFile',
  ]);
}

/**
 * Загрузить файл
 * @param file (optional) 
 * @return OK
 */
export function useUploadFileMutation<TContext>(options?: Omit<UseMutationOptions<Types.FileDto, unknown, UploadFileFilesMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FileDto, unknown, UploadFileFilesMutationParameters, TContext> {
  const key = uploadFileMutationKey();

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useMutation({
    ...options,
    mutationFn: (uploadFileFilesMutationParameters: UploadFileFilesMutationParameters) => Client.uploadFile(uploadFileFilesMutationParameters.file),
    mutationKey: key,
  });
}

export function getFileMetadataUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/files/{id}/metadata";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getFileMetadataDefaultOptions: Omit<UseQueryOptions<Types.FileDto, unknown, Types.FileDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileDto, unknown, Types.FileDto>, 'queryFn'>> = {
};
export function getGetFileMetadataDefaultOptions() {
  return getFileMetadataDefaultOptions;
};
export function setGetFileMetadataDefaultOptions(options: typeof getFileMetadataDefaultOptions) {
  getFileMetadataDefaultOptions = options;
}

export function getFileMetadataQueryKey(id: string): QueryKey;
export function getFileMetadataQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, } = params[0] as GetFileMetadataFilesQueryParameters;

    return trimArrayEnd([
      'FilesClient',
      'getFileMetadata',
      id as any,
    ]);
  } else {
    return trimArrayEnd([
      'FilesClient',
      'getFileMetadata',
      ...params
    ]);
  }
}
export function __getFileMetadata(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getFileMetadata(
    context.queryKey[2] as string, axiosConfig);
}

export function useGetFileMetadataQuery<TSelectData = Types.FileDto, TError = unknown>(dto: GetFileMetadataFilesQueryParameters, options?: Omit<UseQueryOptions<Types.FileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить метаданные файла
 * @param id id файла
 * @return OK
 */
export function useGetFileMetadataQuery<TSelectData = Types.FileDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetFileMetadataQuery<TSelectData = Types.FileDto, TError = unknown>(...params: any[]): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig | undefined = undefined;
  let id: any = undefined;

  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, } = params[0] as GetFileMetadataFilesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getFileMetadata(context, axiosConfig) : __getFileMetadata,
    queryKey: getFileMetadataQueryKey(id),
    ...getFileMetadataDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить метаданные файла
 * @param id id файла
 * @return OK
 */
export function setGetFileMetadataData(queryClient: QueryClient, updater: (data: Types.FileDto | undefined) => Types.FileDto, id: string) {
  queryClient.setQueryData(getFileMetadataQueryKey(id),
    updater
  );
}

/**
 * Получить метаданные файла
 * @param id id файла
 * @return OK
 */
export function setGetFileMetadataDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileDto | undefined) => Types.FileDto) {
  queryClient.setQueryData(queryKey, updater);
}

export function downloadFileUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/files/{id}/download";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let downloadFileDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryFn'>> = {
};
export function getDownloadFileDefaultOptions() {
  return downloadFileDefaultOptions;
};
export function setDownloadFileDefaultOptions(options: typeof downloadFileDefaultOptions) {
  downloadFileDefaultOptions = options;
}

export function downloadFileQueryKey(id: string): QueryKey;
export function downloadFileQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, } = params[0] as DownloadFileFilesQueryParameters;

    return trimArrayEnd([
      'FilesClient',
      'downloadFile',
      id as any,
    ]);
  } else {
    return trimArrayEnd([
      'FilesClient',
      'downloadFile',
      ...params
    ]);
  }
}
export function __downloadFile(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.downloadFile(
    context.queryKey[2] as string, axiosConfig);
}

export function useDownloadFileQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: DownloadFileFilesQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Скачать файл
 * @param id id файла
 * @return OK
 */
export function useDownloadFileQuery<TSelectData = Types.FileResponse, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDownloadFileQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any[]): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig | undefined = undefined;
  let id: any = undefined;

  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, } = params[0] as DownloadFileFilesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __downloadFile(context, axiosConfig) : __downloadFile,
    queryKey: downloadFileQueryKey(id),
    ...downloadFileDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Скачать файл
 * @param id id файла
 * @return OK
 */
export function setDownloadFileData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, id: string) {
  queryClient.setQueryData(downloadFileQueryKey(id),
    updater
  );
}

/**
 * Скачать файл
 * @param id id файла
 * @return OK
 */
export function setDownloadFileDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}

export function getMyFilesUrl(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/files/my?";
  if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
  else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
  if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
  else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
  if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
  else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getMyFilesDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoFileDto, unknown, Types.PagedListDtoFileDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoFileDto, unknown, Types.PagedListDtoFileDto>, 'queryFn'>> = {
};
export function getGetMyFilesDefaultOptions() {
  return getMyFilesDefaultOptions;
};
export function setGetMyFilesDefaultOptions(options: typeof getMyFilesDefaultOptions) {
  getMyFilesDefaultOptions = options;
}

export function getMyFilesQueryKey(dto: GetMyFilesFilesQueryParameters): QueryKey;
export function getMyFilesQueryKey(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getMyFilesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { page, size, sort, } = params[0] as GetMyFilesFilesQueryParameters;

    return trimArrayEnd([
      'FilesClient',
      'getMyFiles',
      page as any,
      size as any,
      sort as any,
    ]);
  } else {
    return trimArrayEnd([
      'FilesClient',
      'getMyFiles',
      ...params
    ]);
  }
}
export function __getMyFiles(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getMyFiles(
    context.queryKey[2] as number | undefined, context.queryKey[3] as number | undefined, context.queryKey[4] as string[] | undefined, axiosConfig);
}

export function useGetMyFilesQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(dto: GetMyFilesFilesQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить свои файлы
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetMyFilesQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetMyFilesQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(...params: any[]): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig | undefined = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;

  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ page, size, sort, } = params[0] as GetMyFilesFilesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoFileDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getMyFiles(context, axiosConfig) : __getMyFiles,
    queryKey: getMyFilesQueryKey(page, size, sort),
    ...getMyFilesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить свои файлы
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetMyFilesData(queryClient: QueryClient, updater: (data: Types.PagedListDtoFileDto | undefined) => Types.PagedListDtoFileDto, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getMyFilesQueryKey(page, size, sort),
    updater
  );
}

/**
 * Получить свои файлы
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetMyFilesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoFileDto | undefined) => Types.PagedListDtoFileDto) {
  queryClient.setQueryData(queryKey, updater);
}

export function getAllFilesByTypeUrl(type: Types.Type, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/files/all?";
  if (type === undefined || type === null)
    throw new Error("The parameter 'type' must be defined and cannot be null.");
  else
    url_ += "type=" + encodeURIComponent("" + type) + "&";
  if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
  else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
  if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
  else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
  if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
  else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAllFilesByTypeDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoFileDto, unknown, Types.PagedListDtoFileDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoFileDto, unknown, Types.PagedListDtoFileDto>, 'queryFn'>> = {
};
export function getGetAllFilesByTypeDefaultOptions() {
  return getAllFilesByTypeDefaultOptions;
};
export function setGetAllFilesByTypeDefaultOptions(options: typeof getAllFilesByTypeDefaultOptions) {
  getAllFilesByTypeDefaultOptions = options;
}

export function getAllFilesByTypeQueryKey(dto: GetAllFilesByTypeFilesQueryParameters): QueryKey;
export function getAllFilesByTypeQueryKey(type: Types.Type, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getAllFilesByTypeQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { type, page, size, sort, } = params[0] as GetAllFilesByTypeFilesQueryParameters;

    return trimArrayEnd([
      'FilesClient',
      'getAllFilesByType',
      type as any,
      page as any,
      size as any,
      sort as any,
    ]);
  } else {
    return trimArrayEnd([
      'FilesClient',
      'getAllFilesByType',
      ...params
    ]);
  }
}
export function __getAllFilesByType(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getAllFilesByType(
    context.queryKey[2] as Types.Type, context.queryKey[3] as number | undefined, context.queryKey[4] as number | undefined, context.queryKey[5] as string[] | undefined, axiosConfig);
}

export function useGetAllFilesByTypeQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(dto: GetAllFilesByTypeFilesQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить все файлы по типу
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetAllFilesByTypeQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(type: Types.Type, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetAllFilesByTypeQuery<TSelectData = Types.PagedListDtoFileDto, TError = unknown>(...params: any[]): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig | undefined = undefined;
  let type: any = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;

  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ type, page, size, sort, } = params[0] as GetAllFilesByTypeFilesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [type, page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoFileDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getAllFilesByType(context, axiosConfig) : __getAllFilesByType,
    queryKey: getAllFilesByTypeQueryKey(type, page, size, sort),
    ...getAllFilesByTypeDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoFileDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить все файлы по типу
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetAllFilesByTypeData(queryClient: QueryClient, updater: (data: Types.PagedListDtoFileDto | undefined) => Types.PagedListDtoFileDto, type: Types.Type, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getAllFilesByTypeQueryKey(type, page, size, sort),
    updater
  );
}

/**
 * Получить все файлы по типу
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetAllFilesByTypeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoFileDto | undefined) => Types.PagedListDtoFileDto) {
  queryClient.setQueryData(queryKey, updater);
}

export function deleteFileUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/files/{id}";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteFileMutationKey(id: string): MutationKey {
  return trimArrayEnd([
    'FilesClient',
    'deleteFile',
    id as any,
  ]);
}

/**
 * Удалить файл
 * @param id id файла
 * @return OK
 */
export function useDeleteFileMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.Response, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, void, TContext> {
  const key = deleteFileMutationKey(id);

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useMutation({
    ...options,
    mutationFn: () => Client.deleteFile(id),
    mutationKey: key,
  });
}

type DeleteFile__MutationParameters = DeleteFileFilesQueryParameters

/**
 * Удалить файл
 * @param id id файла
 * @return OK
 */
export function useDeleteFileMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, DeleteFile__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteFileFilesQueryParameters }): UseMutationResult<Types.Response, unknown, DeleteFile__MutationParameters, TContext> {
  const key = deleteFileMutationKey(options?.parameters?.id!);

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useMutation({
    ...options,
    mutationFn: (data: DeleteFile__MutationParameters) => Client.deleteFile(data.id ?? options?.parameters?.id!),
    mutationKey: key,
  });
}