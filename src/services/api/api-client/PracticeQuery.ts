//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './PracticeClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type GetCurrentStudentPracticePracticeQueryParameters = {
  id: string ;
}

export type UpdatePracticePracticeQueryParameters = {
  id: string ;
}

export type ArchiveStudentPracticePracticeQueryParameters = {
  id: string ;
}

export type ArchiveStudentPracticesByGroupPracticeQueryParameters = {
  groupId: string ;
}

export type ApproveStudentPracticePracticeQueryParameters = {
  id: string ;
}

export type ApproveStudentPracticesPracticeQueryParameters = {
  id: string[] ;
}

export type ApproveStudentPractices_1PracticeQueryParameters = {
  companyId: string ;
}

export type GetStudentPracticesPracticeQueryParameters = {
  id: string ;
  page?: number | undefined ;
  size?: number | undefined ;
  sort?: string[] | undefined ;
}

export type GetPracticeRequestsPracticeQueryParameters = {
  page?: number | undefined ;
  size?: number | undefined ;
  sort?: string[] | undefined ;
}

export type GetAllPracticesPracticeQueryParameters = {
  studentName?: string | undefined ;
  groupIds?: string[] | undefined ;
  companyId?: string | undefined ;
  hasReport?: boolean | undefined ;
  isReportApproved?: boolean | undefined ;
  isArchived?: boolean | undefined ;
  isPracticeApproved?: boolean | undefined ;
  page?: number | undefined ;
  size?: number | undefined ;
  sort?: string[] | undefined ;
}

export function getCurrentStudentPracticeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCurrentStudentPracticeDefaultOptions: Omit<UseQueryOptions<Types.PracticeDto, unknown, Types.PracticeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PracticeDto, unknown, Types.PracticeDto>, 'queryFn'>> = {
};
export function getGetCurrentStudentPracticeDefaultOptions() {
  return getCurrentStudentPracticeDefaultOptions;
};
export function setGetCurrentStudentPracticeDefaultOptions(options: typeof getCurrentStudentPracticeDefaultOptions) {
  getCurrentStudentPracticeDefaultOptions = options;
}

export function getCurrentStudentPracticeQueryKey(id: string): QueryKey;
export function getCurrentStudentPracticeQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetCurrentStudentPracticePracticeQueryParameters;

    return trimArrayEnd([
        'PracticeClient',
        'getCurrentStudentPractice',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'PracticeClient',
        'getCurrentStudentPractice',
        ...params
      ]);
  }
}
export function __getCurrentStudentPractice(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getCurrentStudentPractice(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetCurrentStudentPracticeQuery<TSelectData = Types.PracticeDto, TError = unknown>(dto: GetCurrentStudentPracticePracticeQueryParameters, options?: Omit<UseQueryOptions<Types.PracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получение информации о практике студента
 * @param id Id студента
 * @return OK
 */
export function useGetCurrentStudentPracticeQuery<TSelectData = Types.PracticeDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.PracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetCurrentStudentPracticeQuery<TSelectData = Types.PracticeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PracticeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetCurrentStudentPracticePracticeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PracticeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getCurrentStudentPractice(context, axiosConfig) : __getCurrentStudentPractice,
    queryKey: getCurrentStudentPracticeQueryKey(id),
    ...getCurrentStudentPracticeDefaultOptions as unknown as Omit<UseQueryOptions<Types.PracticeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получение информации о практике студента
 * @param id Id студента
 * @return OK
 */
export function setGetCurrentStudentPracticeData(queryClient: QueryClient, updater: (data: Types.PracticeDto | undefined) => Types.PracticeDto, id: string) {
  queryClient.setQueryData(getCurrentStudentPracticeQueryKey(id),
    updater
  );
}

/**
 * Получение информации о практике студента
 * @param id Id студента
 * @return OK
 */
export function setGetCurrentStudentPracticeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PracticeDto | undefined) => Types.PracticeDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updatePracticeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePracticeMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'updatePractice',
      id as any,
    ]);
}

/**
 * Обновление практики
 * @param id Id практики
 * @return OK
 */
export function useUpdatePracticeMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, Types.UpdatePracticeDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PracticeDto, unknown, Types.UpdatePracticeDto, TContext> {
  const key = updatePracticeMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UpdatePracticeDto) => Client.updatePractice(id, body),
    mutationKey: key,
  });
}
  
type UpdatePractice__MutationParameters = UpdatePracticePracticeQueryParameters & {
  body: Types.UpdatePracticeDto;
}

/**
 * Обновление практики
 * @param id Id практики
 * @return OK
 */
export function useUpdatePracticeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, UpdatePractice__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePracticePracticeQueryParameters}): UseMutationResult<Types.PracticeDto, unknown, UpdatePractice__MutationParameters, TContext> {
  const key = updatePracticeMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdatePractice__MutationParameters) => Client.updatePractice(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function createStudentPracticeUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/practice";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createStudentPracticeMutationKey(): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'createStudentPractice',
    ]);
}

/**
 * Подача заявки на практику студента
 * @return OK
 */
export function useCreateStudentPracticeMutation<TContext>(options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, Types.CreatePracticeDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PracticeDto, unknown, Types.CreatePracticeDto, TContext> {
  const key = createStudentPracticeMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreatePracticeDto) => Client.createStudentPractice(body),
    mutationKey: key,
  });
}
  
export function archiveStudentPracticeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice/archive?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function archiveStudentPracticeMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'archiveStudentPractice',
      id as any,
    ]);
}

/**
 * Заархивирование практики студента
 * @param id Id практики
 * @return OK
 */
export function useArchiveStudentPracticeMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PracticeDto, unknown, void, TContext> {
  const key = archiveStudentPracticeMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.archiveStudentPractice(id),
    mutationKey: key,
  });
}
  
type ArchiveStudentPractice__MutationParameters = ArchiveStudentPracticePracticeQueryParameters

/**
 * Заархивирование практики студента
 * @param id Id практики
 * @return OK
 */
export function useArchiveStudentPracticeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, ArchiveStudentPractice__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ArchiveStudentPracticePracticeQueryParameters}): UseMutationResult<Types.PracticeDto, unknown, ArchiveStudentPractice__MutationParameters, TContext> {
  const key = archiveStudentPracticeMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ArchiveStudentPractice__MutationParameters) => Client.archiveStudentPractice(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function archiveStudentPracticesByGroupUrl(groupId: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice/archiveAll?";
  if (groupId === undefined || groupId === null)
    throw new Error("The parameter 'groupId' must be defined and cannot be null.");
  else
    url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function archiveStudentPracticesByGroupMutationKey(groupId: string): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'archiveStudentPracticesByGroup',
      groupId as any,
    ]);
}

/**
 * Заархивирование практик студентов конкретной группы
 * @param groupId Id группы
 * @return OK
 */
export function useArchiveStudentPracticesByGroupMutation<TContext>(groupId: string, options?: Omit<UseMutationOptions<Types.Response, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, void, TContext> {
  const key = archiveStudentPracticesByGroupMutationKey(groupId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.archiveStudentPracticesByGroup(groupId),
    mutationKey: key,
  });
}
  
type ArchiveStudentPracticesByGroup__MutationParameters = ArchiveStudentPracticesByGroupPracticeQueryParameters

/**
 * Заархивирование практик студентов конкретной группы
 * @param groupId Id группы
 * @return OK
 */
export function useArchiveStudentPracticesByGroupMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, ArchiveStudentPracticesByGroup__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ArchiveStudentPracticesByGroupPracticeQueryParameters}): UseMutationResult<Types.Response, unknown, ArchiveStudentPracticesByGroup__MutationParameters, TContext> {
  const key = archiveStudentPracticesByGroupMutationKey(options?.parameters?.groupId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ArchiveStudentPracticesByGroup__MutationParameters) => Client.archiveStudentPracticesByGroup(data.groupId ?? options?.parameters?.groupId!),
  mutationKey: key,
});
}
  
export function approveStudentPracticeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice/approve?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function approveStudentPracticeMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'approveStudentPractice',
      id as any,
    ]);
}

/**
 * Подтверждение практики студента
 * @param id Id студента
 * @return OK
 */
export function useApproveStudentPracticeMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PracticeDto, unknown, void, TContext> {
  const key = approveStudentPracticeMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.approveStudentPractice(id),
    mutationKey: key,
  });
}
  
type ApproveStudentPractice__MutationParameters = ApproveStudentPracticePracticeQueryParameters

/**
 * Подтверждение практики студента
 * @param id Id студента
 * @return OK
 */
export function useApproveStudentPracticeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PracticeDto, unknown, ApproveStudentPractice__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ApproveStudentPracticePracticeQueryParameters}): UseMutationResult<Types.PracticeDto, unknown, ApproveStudentPractice__MutationParameters, TContext> {
  const key = approveStudentPracticeMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ApproveStudentPractice__MutationParameters) => Client.approveStudentPractice(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function approveStudentPracticesUrl(id: string[]): string {
  let url_ = getBaseUrl() + "/api/v1/practice/approveMany?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function approveStudentPracticesMutationKey(id: string[]): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'approveStudentPractices',
      id as any,
    ]);
}

/**
 * Подтверждение практик студентов
 * @param id Id практик
 * @return OK
 */
export function useApproveStudentPracticesMutation<TContext>(id: string[], options?: Omit<UseMutationOptions<Types.Response, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, void, TContext> {
  const key = approveStudentPracticesMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.approveStudentPractices(id),
    mutationKey: key,
  });
}
  
type ApproveStudentPractices__MutationParameters = ApproveStudentPracticesPracticeQueryParameters

/**
 * Подтверждение практик студентов
 * @param id Id практик
 * @return OK
 */
export function useApproveStudentPracticesMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, ApproveStudentPractices__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ApproveStudentPracticesPracticeQueryParameters}): UseMutationResult<Types.Response, unknown, ApproveStudentPractices__MutationParameters, TContext> {
  const key = approveStudentPracticesMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ApproveStudentPractices__MutationParameters) => Client.approveStudentPractices(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function approveStudentPractices_1Url(companyId: string): string {
  let url_ = getBaseUrl() + "/api/v1/practice/approveAll?";
  if (companyId === undefined || companyId === null)
    throw new Error("The parameter 'companyId' must be defined and cannot be null.");
  else
    url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function approveStudentPractices_1MutationKey(companyId: string): MutationKey {
  return trimArrayEnd([
      'PracticeClient',
      'approveStudentPractices_1',
      companyId as any,
    ]);
}

/**
 * Подтверждение практики студентов в компании
 * @param companyId Id компании-партнера
 * @return OK
 */
export function useApproveStudentPractices_1Mutation<TContext>(companyId: string, options?: Omit<UseMutationOptions<Types.Response, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, void, TContext> {
  const key = approveStudentPractices_1MutationKey(companyId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.approveStudentPractices_1(companyId),
    mutationKey: key,
  });
}
  
type ApproveStudentPractices_1__MutationParameters = ApproveStudentPractices_1PracticeQueryParameters

/**
 * Подтверждение практики студентов в компании
 * @param companyId Id компании-партнера
 * @return OK
 */
export function useApproveStudentPractices_1MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, ApproveStudentPractices_1__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ApproveStudentPractices_1PracticeQueryParameters}): UseMutationResult<Types.Response, unknown, ApproveStudentPractices_1__MutationParameters, TContext> {
  const key = approveStudentPractices_1MutationKey(options?.parameters?.companyId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ApproveStudentPractices_1__MutationParameters) => Client.approveStudentPractices_1(data.companyId ?? options?.parameters?.companyId!),
  mutationKey: key,
});
}
  
export function getMyPracticeUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/practice/my";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getMyPracticeDefaultOptions: Omit<UseQueryOptions<Types.PracticeDto, unknown, Types.PracticeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PracticeDto, unknown, Types.PracticeDto>, 'queryFn'>> = {
};
export function getGetMyPracticeDefaultOptions() {
  return getMyPracticeDefaultOptions;
};
export function setGetMyPracticeDefaultOptions(options: typeof getMyPracticeDefaultOptions) {
  getMyPracticeDefaultOptions = options;
}

export function getMyPracticeQueryKey(): QueryKey;
export function getMyPracticeQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'PracticeClient',
      'getMyPractice',
    ]);
}
export function __getMyPractice(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getMyPractice(
axiosConfig    );
}

/**
 * Получение информации о практике студентом
 * @return OK
 */
export function useGetMyPracticeQuery<TSelectData = Types.PracticeDto, TError = unknown>(options?: Omit<UseQueryOptions<Types.PracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetMyPracticeQuery<TSelectData = Types.PracticeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PracticeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PracticeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getMyPractice(context, axiosConfig) : __getMyPractice,
    queryKey: getMyPracticeQueryKey(),
    ...getMyPracticeDefaultOptions as unknown as Omit<UseQueryOptions<Types.PracticeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получение информации о практике студентом
 * @return OK
 */
export function setGetMyPracticeData(queryClient: QueryClient, updater: (data: Types.PracticeDto | undefined) => Types.PracticeDto, ) {
  queryClient.setQueryData(getMyPracticeQueryKey(),
    updater
  );
}

/**
 * Получение информации о практике студентом
 * @return OK
 */
export function setGetMyPracticeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PracticeDto | undefined) => Types.PracticeDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getStudentPracticesUrl(id: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/practice/list?";
  if (id === undefined || id === null)
    throw new Error("The parameter 'id' must be defined and cannot be null.");
  else
    url_ += "id=" + encodeURIComponent("" + id) + "&";
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getStudentPracticesDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryFn'>> = {
};
export function getGetStudentPracticesDefaultOptions() {
  return getStudentPracticesDefaultOptions;
};
export function setGetStudentPracticesDefaultOptions(options: typeof getStudentPracticesDefaultOptions) {
  getStudentPracticesDefaultOptions = options;
}

export function getStudentPracticesQueryKey(dto: GetStudentPracticesPracticeQueryParameters): QueryKey;
export function getStudentPracticesQueryKey(id: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getStudentPracticesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, page, size, sort,  } = params[0] as GetStudentPracticesPracticeQueryParameters;

    return trimArrayEnd([
        'PracticeClient',
        'getStudentPractices',
        id as any,
        page as any,
        size as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'PracticeClient',
        'getStudentPractices',
        ...params
      ]);
  }
}
export function __getStudentPractices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getStudentPractices(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string[] | undefined,axiosConfig    );
}

export function useGetStudentPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(dto: GetStudentPracticesPracticeQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить список практик студента
 * @param id Id студента
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetStudentPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(id: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetStudentPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, page, size, sort,  } = params[0] as GetStudentPracticesPracticeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoPracticeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getStudentPractices(context, axiosConfig) : __getStudentPractices,
    queryKey: getStudentPracticesQueryKey(id, page, size, sort),
    ...getStudentPracticesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить список практик студента
 * @param id Id студента
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetStudentPracticesData(queryClient: QueryClient, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto, id: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getStudentPracticesQueryKey(id, page, size, sort),
    updater
  );
}

/**
 * Получить список практик студента
 * @param id Id студента
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetStudentPracticesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPracticeRequestsUrl(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/practice/list/unapproved?";
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPracticeRequestsDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryFn'>> = {
};
export function getGetPracticeRequestsDefaultOptions() {
  return getPracticeRequestsDefaultOptions;
};
export function setGetPracticeRequestsDefaultOptions(options: typeof getPracticeRequestsDefaultOptions) {
  getPracticeRequestsDefaultOptions = options;
}

export function getPracticeRequestsQueryKey(dto: GetPracticeRequestsPracticeQueryParameters): QueryKey;
export function getPracticeRequestsQueryKey(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getPracticeRequestsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { page, size, sort,  } = params[0] as GetPracticeRequestsPracticeQueryParameters;

    return trimArrayEnd([
        'PracticeClient',
        'getPracticeRequests',
        page as any,
        size as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'PracticeClient',
        'getPracticeRequests',
        ...params
      ]);
  }
}
export function __getPracticeRequests(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getPracticeRequests(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string[] | undefined,axiosConfig    );
}

export function useGetPracticeRequestsQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(dto: GetPracticeRequestsPracticeQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить заявки на практику
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetPracticeRequestsQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetPracticeRequestsQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ page, size, sort,  } = params[0] as GetPracticeRequestsPracticeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoPracticeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPracticeRequests(context, axiosConfig) : __getPracticeRequests,
    queryKey: getPracticeRequestsQueryKey(page, size, sort),
    ...getPracticeRequestsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить заявки на практику
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetPracticeRequestsData(queryClient: QueryClient, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getPracticeRequestsQueryKey(page, size, sort),
    updater
  );
}

/**
 * Получить заявки на практику
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetPracticeRequestsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getAllPracticesUrl(studentName?: string | undefined, groupIds?: string[] | undefined, companyId?: string | undefined, hasReport?: boolean | undefined, isReportApproved?: boolean | undefined, isArchived?: boolean | undefined, isPracticeApproved?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/practice/list/all?";
if (studentName === null)
    throw new Error("The parameter 'studentName' cannot be null.");
else if (studentName !== undefined)
    url_ += "studentName=" + encodeURIComponent("" + studentName) + "&";
if (groupIds === null)
    throw new Error("The parameter 'groupIds' cannot be null.");
else if (groupIds !== undefined)
    groupIds && groupIds.forEach(item => { url_ += "groupIds=" + encodeURIComponent("" + item) + "&"; });
if (companyId === null)
    throw new Error("The parameter 'companyId' cannot be null.");
else if (companyId !== undefined)
    url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
if (hasReport === null)
    throw new Error("The parameter 'hasReport' cannot be null.");
else if (hasReport !== undefined)
    url_ += "hasReport=" + encodeURIComponent("" + hasReport) + "&";
if (isReportApproved === null)
    throw new Error("The parameter 'isReportApproved' cannot be null.");
else if (isReportApproved !== undefined)
    url_ += "isReportApproved=" + encodeURIComponent("" + isReportApproved) + "&";
if (isArchived === null)
    throw new Error("The parameter 'isArchived' cannot be null.");
else if (isArchived !== undefined)
    url_ += "isArchived=" + encodeURIComponent("" + isArchived) + "&";
if (isPracticeApproved === null)
    throw new Error("The parameter 'isPracticeApproved' cannot be null.");
else if (isPracticeApproved !== undefined)
    url_ += "isPracticeApproved=" + encodeURIComponent("" + isPracticeApproved) + "&";
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAllPracticesDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoPracticeDto, unknown, Types.PagedListDtoPracticeDto>, 'queryFn'>> = {
};
export function getGetAllPracticesDefaultOptions() {
  return getAllPracticesDefaultOptions;
};
export function setGetAllPracticesDefaultOptions(options: typeof getAllPracticesDefaultOptions) {
  getAllPracticesDefaultOptions = options;
}

export function getAllPracticesQueryKey(dto: GetAllPracticesPracticeQueryParameters): QueryKey;
export function getAllPracticesQueryKey(studentName?: string | undefined, groupIds?: string[] | undefined, companyId?: string | undefined, hasReport?: boolean | undefined, isReportApproved?: boolean | undefined, isArchived?: boolean | undefined, isPracticeApproved?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getAllPracticesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { studentName, groupIds, companyId, hasReport, isReportApproved, isArchived, isPracticeApproved, page, size, sort,  } = params[0] as GetAllPracticesPracticeQueryParameters;

    return trimArrayEnd([
        'PracticeClient',
        'getAllPractices',
        studentName as any,
        groupIds as any,
        companyId as any,
        hasReport as any,
        isReportApproved as any,
        isArchived as any,
        isPracticeApproved as any,
        page as any,
        size as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'PracticeClient',
        'getAllPractices',
        ...params
      ]);
  }
}
export function __getAllPractices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getAllPractices(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string[] | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as boolean | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as boolean | undefined,       context.queryKey[8] as boolean | undefined,       context.queryKey[9] as number | undefined,       context.queryKey[10] as number | undefined,       context.queryKey[11] as string[] | undefined,axiosConfig    );
}

export function useGetAllPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(dto: GetAllPracticesPracticeQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить список практик всех студентов
 * @param studentName (optional) Имя студента
 * @param groupIds (optional) Список идентификаторов групп
 * @param companyId (optional) Идентификатор компании-партнера
 * @param hasReport (optional) Флаг выбора практик с прикрепленным отчетом или без. null - если все
 * @param isReportApproved (optional) Флаг выдачи практик с подтвержденным отчетом
 * @param isArchived (optional) Флаг выдачи архивных данных
 * @param isPracticeApproved (optional) Флаг подтвержденных практик
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetAllPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(studentName?: string | undefined, groupIds?: string[] | undefined, companyId?: string | undefined, hasReport?: boolean | undefined, isReportApproved?: boolean | undefined, isArchived?: boolean | undefined, isPracticeApproved?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetAllPracticesQuery<TSelectData = Types.PagedListDtoPracticeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let studentName: any = undefined;
  let groupIds: any = undefined;
  let companyId: any = undefined;
  let hasReport: any = undefined;
  let isReportApproved: any = undefined;
  let isArchived: any = undefined;
  let isPracticeApproved: any = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ studentName, groupIds, companyId, hasReport, isReportApproved, isArchived, isPracticeApproved, page, size, sort,  } = params[0] as GetAllPracticesPracticeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [studentName, groupIds, companyId, hasReport, isReportApproved, isArchived, isPracticeApproved, page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoPracticeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getAllPractices(context, axiosConfig) : __getAllPractices,
    queryKey: getAllPracticesQueryKey(studentName, groupIds, companyId, hasReport, isReportApproved, isArchived, isPracticeApproved, page, size, sort),
    ...getAllPracticesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoPracticeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить список практик всех студентов
 * @param studentName (optional) Имя студента
 * @param groupIds (optional) Список идентификаторов групп
 * @param companyId (optional) Идентификатор компании-партнера
 * @param hasReport (optional) Флаг выбора практик с прикрепленным отчетом или без. null - если все
 * @param isReportApproved (optional) Флаг выдачи практик с подтвержденным отчетом
 * @param isArchived (optional) Флаг выдачи архивных данных
 * @param isPracticeApproved (optional) Флаг подтвержденных практик
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetAllPracticesData(queryClient: QueryClient, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto, studentName?: string | undefined, groupIds?: string[] | undefined, companyId?: string | undefined, hasReport?: boolean | undefined, isReportApproved?: boolean | undefined, isArchived?: boolean | undefined, isPracticeApproved?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getAllPracticesQueryKey(studentName, groupIds, companyId, hasReport, isReportApproved, isArchived, isPracticeApproved, page, size, sort),
    updater
  );
}

/**
 * Получить список практик всех студентов
 * @param studentName (optional) Имя студента
 * @param groupIds (optional) Список идентификаторов групп
 * @param companyId (optional) Идентификатор компании-партнера
 * @param hasReport (optional) Флаг выбора практик с прикрепленным отчетом или без. null - если все
 * @param isReportApproved (optional) Флаг выдачи практик с подтвержденным отчетом
 * @param isArchived (optional) Флаг выдачи архивных данных
 * @param isPracticeApproved (optional) Флаг подтвержденных практик
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetAllPracticesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoPracticeDto | undefined) => Types.PagedListDtoPracticeDto) {
  queryClient.setQueryData(queryKey, updater);
}