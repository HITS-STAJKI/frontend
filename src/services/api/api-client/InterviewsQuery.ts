//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
//@ts-nocheck
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './InterviewsClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type GetInterviewInterviewsQueryParameters = {
  interviewId: string ;
}

export type UpdateInterviewInterviewsQueryParameters = {
  interviewId: string ;
}

export type DeleteInterviewInterviewsQueryParameters = {
  interviewId: string ;
}

export type GetInterviewListInterviewsQueryParameters = {
  studentName?: string | undefined ;
  partnerId?: string | undefined ;
  stackId?: string | undefined ;
  languageIds?: string[] | undefined ;
  studentGroupId?: string | undefined ;
  status?: Types.Status | undefined ;
  modifiedAtFrom?: Date | undefined ;
  modifiedAtTo?: Date | undefined ;
  page?: number | undefined ;
  size?: number | undefined ;
  sort?: string[] | undefined ;
}

export type GetInterviewList_1InterviewsQueryParameters = {
  page?: number | undefined ;
  size?: number | undefined ;
  sort?: string[] | undefined ;
}

export function getInterviewUrl(interviewId: string): string {
  let url_ = getBaseUrl() + "/api/v1/interview/{interviewId}";
if (interviewId === undefined || interviewId === null)
  throw new Error("The parameter 'interviewId' must be defined.");
url_ = url_.replace("{interviewId}", encodeURIComponent("" + interviewId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInterviewDefaultOptions: Omit<UseQueryOptions<Types.InterviewDto, unknown, Types.InterviewDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.InterviewDto, unknown, Types.InterviewDto>, 'queryFn'>> = {
};
export function getGetInterviewDefaultOptions() {
  return getInterviewDefaultOptions;
};
export function setGetInterviewDefaultOptions(options: typeof getInterviewDefaultOptions) {
  getInterviewDefaultOptions = options;
}

export function getInterviewQueryKey(interviewId: string): QueryKey;
export function getInterviewQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { interviewId,  } = params[0] as GetInterviewInterviewsQueryParameters;

    return trimArrayEnd([
        'InterviewsClient',
        'getInterview',
        interviewId as any,
      ]);
  } else {
    return trimArrayEnd([
        'InterviewsClient',
        'getInterview',
        ...params
      ]);
  }
}
export function __getInterview(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getInterview(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetInterviewQuery<TSelectData = Types.InterviewDto, TError = unknown>(dto: GetInterviewInterviewsQueryParameters, options?: Omit<UseQueryOptions<Types.InterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function useGetInterviewQuery<TSelectData = Types.InterviewDto, TError = unknown>(interviewId: string, options?: Omit<UseQueryOptions<Types.InterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetInterviewQuery<TSelectData = Types.InterviewDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.InterviewDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let interviewId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ interviewId,  } = params[0] as GetInterviewInterviewsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [interviewId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.InterviewDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getInterview(context, axiosConfig) : __getInterview,
    queryKey: getInterviewQueryKey(interviewId),
    ...getInterviewDefaultOptions as unknown as Omit<UseQueryOptions<Types.InterviewDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function setGetInterviewData(queryClient: QueryClient, updater: (data: Types.InterviewDto | undefined) => Types.InterviewDto, interviewId: string) {
  queryClient.setQueryData(getInterviewQueryKey(interviewId),
    updater
  );
}

/**
 * Получить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function setGetInterviewDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.InterviewDto | undefined) => Types.InterviewDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateInterviewUrl(interviewId: string): string {
  let url_ = getBaseUrl() + "/api/v1/interview/{interviewId}";
if (interviewId === undefined || interviewId === null)
  throw new Error("The parameter 'interviewId' must be defined.");
url_ = url_.replace("{interviewId}", encodeURIComponent("" + interviewId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateInterviewMutationKey(interviewId: string): MutationKey {
  return trimArrayEnd([
      'InterviewsClient',
      'updateInterview',
      interviewId as any,
    ]);
}

/**
 * Обновить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function useUpdateInterviewMutation<TContext>(interviewId: string, options?: Omit<UseMutationOptions<Types.InterviewDto, unknown, Types.UpdateInterviewDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InterviewDto, unknown, Types.UpdateInterviewDto, TContext> {
  const key = updateInterviewMutationKey(interviewId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UpdateInterviewDto) => Client.updateInterview(interviewId, body),
    mutationKey: key,
  });
}
  
type UpdateInterview__MutationParameters = UpdateInterviewInterviewsQueryParameters & {
  body: Types.UpdateInterviewDto;
}

/**
 * Обновить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function useUpdateInterviewMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.InterviewDto, unknown, UpdateInterview__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateInterviewInterviewsQueryParameters}): UseMutationResult<Types.InterviewDto, unknown, UpdateInterview__MutationParameters, TContext> {
  const key = updateInterviewMutationKey(options?.parameters?.interviewId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateInterview__MutationParameters) => Client.updateInterview(data.interviewId ?? options?.parameters?.interviewId!, data.body),
  mutationKey: key,
});
}
  
export function deleteInterviewUrl(interviewId: string): string {
  let url_ = getBaseUrl() + "/api/v1/interview/{interviewId}";
if (interviewId === undefined || interviewId === null)
  throw new Error("The parameter 'interviewId' must be defined.");
url_ = url_.replace("{interviewId}", encodeURIComponent("" + interviewId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteInterviewMutationKey(interviewId: string): MutationKey {
  return trimArrayEnd([
      'InterviewsClient',
      'deleteInterview',
      interviewId as any,
    ]);
}

/**
 * Удалить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function useDeleteInterviewMutation<TContext>(interviewId: string, options?: Omit<UseMutationOptions<Types.Response, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, void, TContext> {
  const key = deleteInterviewMutationKey(interviewId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deleteInterview(interviewId),
    mutationKey: key,
  });
}
  
type DeleteInterview__MutationParameters = DeleteInterviewInterviewsQueryParameters

/**
 * Удалить отбор
 * @param interviewId Id отбора
 * @return OK
 */
export function useDeleteInterviewMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, DeleteInterview__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteInterviewInterviewsQueryParameters}): UseMutationResult<Types.Response, unknown, DeleteInterview__MutationParameters, TContext> {
  const key = deleteInterviewMutationKey(options?.parameters?.interviewId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteInterview__MutationParameters) => Client.deleteInterview(data.interviewId ?? options?.parameters?.interviewId!),
  mutationKey: key,
});
}
  
export function createInterviewUrl(): string {
  let url_ = getBaseUrl() + "/api/v1/interview";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createInterviewMutationKey(): MutationKey {
  return trimArrayEnd([
      'InterviewsClient',
      'createInterview',
    ]);
}

/**
 * Создать отбор
 * @return OK
 */
export function useCreateInterviewMutation<TContext>(options?: Omit<UseMutationOptions<Types.InterviewDto, unknown, Types.CreateInterviewDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InterviewDto, unknown, Types.CreateInterviewDto, TContext> {
  const key = createInterviewMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreateInterviewDto) => Client.createInterview(body),
    mutationKey: key,
  });
}
  
export function getInterviewListUrl(studentName?: string | undefined, partnerId?: string | undefined, stackId?: string | undefined, languageIds?: string[] | undefined, studentGroupId?: string | undefined, status?: Types.Status | undefined, modifiedAtFrom?: Date | undefined, modifiedAtTo?: Date | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/interview/program-lead/list?";
if (studentName === null)
    throw new Error("The parameter 'studentName' cannot be null.");
else if (studentName !== undefined)
    url_ += "studentName=" + encodeURIComponent("" + studentName) + "&";
if (partnerId === null)
    throw new Error("The parameter 'partnerId' cannot be null.");
else if (partnerId !== undefined)
    url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
if (stackId === null)
    throw new Error("The parameter 'stackId' cannot be null.");
else if (stackId !== undefined)
    url_ += "stackId=" + encodeURIComponent("" + stackId) + "&";
if (languageIds === null)
    throw new Error("The parameter 'languageIds' cannot be null.");
else if (languageIds !== undefined)
    languageIds && languageIds.forEach(item => { url_ += "languageIds=" + encodeURIComponent("" + item) + "&"; });
if (studentGroupId === null)
    throw new Error("The parameter 'studentGroupId' cannot be null.");
else if (studentGroupId !== undefined)
    url_ += "studentGroupId=" + encodeURIComponent("" + studentGroupId) + "&";
if (status === null)
    throw new Error("The parameter 'status' cannot be null.");
else if (status !== undefined)
    url_ += "status=" + encodeURIComponent("" + status) + "&";
if (modifiedAtFrom === null)
    throw new Error("The parameter 'modifiedAtFrom' cannot be null.");
else if (modifiedAtFrom !== undefined)
    url_ += "modifiedAtFrom=" + encodeURIComponent(modifiedAtFrom ? "" + modifiedAtFrom.toISOString() : "") + "&";
if (modifiedAtTo === null)
    throw new Error("The parameter 'modifiedAtTo' cannot be null.");
else if (modifiedAtTo !== undefined)
    url_ += "modifiedAtTo=" + encodeURIComponent(modifiedAtTo ? "" + modifiedAtTo.toISOString() : "") + "&";
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInterviewListDefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, unknown, Types.PagedListDtoInterviewDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoInterviewDto, unknown, Types.PagedListDtoInterviewDto>, 'queryFn'>> = {
};
export function getGetInterviewListDefaultOptions() {
  return getInterviewListDefaultOptions;
};
export function setGetInterviewListDefaultOptions(options: typeof getInterviewListDefaultOptions) {
  getInterviewListDefaultOptions = options;
}

export function getInterviewListQueryKey(dto: GetInterviewListInterviewsQueryParameters): QueryKey;
export function getInterviewListQueryKey(studentName?: string | undefined, partnerId?: string | undefined, stackId?: string | undefined, languageIds?: string[] | undefined, studentGroupId?: string | undefined, status?: Types.Status | undefined, modifiedAtFrom?: Date | undefined, modifiedAtTo?: Date | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getInterviewListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { studentName, partnerId, stackId, languageIds, studentGroupId, status, modifiedAtFrom, modifiedAtTo, page, size, sort,  } = params[0] as GetInterviewListInterviewsQueryParameters;

    return trimArrayEnd([
        'InterviewsClient',
        'getInterviewList',
        studentName as any,
        partnerId as any,
        stackId as any,
        languageIds as any,
        studentGroupId as any,
        status as any,
        modifiedAtFrom as any,
        modifiedAtTo as any,
        page as any,
        size as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'InterviewsClient',
        'getInterviewList',
        ...params
      ]);
  }
}
export function __getInterviewList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getInterviewList(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as string[] | undefined,       context.queryKey[6] as string | undefined,       context.queryKey[7] as Types.Status | undefined,       context.queryKey[8] as Date | undefined,       context.queryKey[9] as Date | undefined,       context.queryKey[10] as number | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as string[] | undefined,axiosConfig    );
}

export function useGetInterviewListQuery<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(dto: GetInterviewListInterviewsQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить список отборов
 * @param studentName (optional) ФИО студента (разрешается частичное совпадение)
 * @param partnerId (optional) Идентификатор компании-партнера
 * @param stackId (optional) Идентификатор стека
 * @param languageIds (optional) Идентификаторы ЯПов
 * @param studentGroupId (optional) Идентификатор группы
 * @param status (optional) Статус отбора
 * @param modifiedAtFrom (optional) Время последнего обновления отборов (от)
 * @param modifiedAtTo (optional) Время последнего обновления отборов (до)
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetInterviewListQuery<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(studentName?: string | undefined, partnerId?: string | undefined, stackId?: string | undefined, languageIds?: string[] | undefined, studentGroupId?: string | undefined, status?: Types.Status | undefined, modifiedAtFrom?: Date | undefined, modifiedAtTo?: Date | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetInterviewListQuery<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let studentName: any = undefined;
  let partnerId: any = undefined;
  let stackId: any = undefined;
  let languageIds: any = undefined;
  let studentGroupId: any = undefined;
  let status: any = undefined;
  let modifiedAtFrom: any = undefined;
  let modifiedAtTo: any = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ studentName, partnerId, stackId, languageIds, studentGroupId, status, modifiedAtFrom, modifiedAtTo, page, size, sort,  } = params[0] as GetInterviewListInterviewsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [studentName, partnerId, stackId, languageIds, studentGroupId, status, modifiedAtFrom, modifiedAtTo, page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoInterviewDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getInterviewList(context, axiosConfig) : __getInterviewList,
    queryKey: getInterviewListQueryKey(studentName, partnerId, stackId, languageIds, studentGroupId, status, modifiedAtFrom, modifiedAtTo, page, size, sort),
    ...getInterviewListDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить список отборов
 * @param studentName (optional) ФИО студента (разрешается частичное совпадение)
 * @param partnerId (optional) Идентификатор компании-партнера
 * @param stackId (optional) Идентификатор стека
 * @param languageIds (optional) Идентификаторы ЯПов
 * @param studentGroupId (optional) Идентификатор группы
 * @param status (optional) Статус отбора
 * @param modifiedAtFrom (optional) Время последнего обновления отборов (от)
 * @param modifiedAtTo (optional) Время последнего обновления отборов (до)
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetInterviewListData(queryClient: QueryClient, updater: (data: Types.PagedListDtoInterviewDto | undefined) => Types.PagedListDtoInterviewDto, studentName?: string | undefined, partnerId?: string | undefined, stackId?: string | undefined, languageIds?: string[] | undefined, studentGroupId?: string | undefined, status?: Types.Status | undefined, modifiedAtFrom?: Date | undefined, modifiedAtTo?: Date | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getInterviewListQueryKey(studentName, partnerId, stackId, languageIds, studentGroupId, status, modifiedAtFrom, modifiedAtTo, page, size, sort),
    updater
  );
}

/**
 * Получить список отборов
 * @param studentName (optional) ФИО студента (разрешается частичное совпадение)
 * @param partnerId (optional) Идентификатор компании-партнера
 * @param stackId (optional) Идентификатор стека
 * @param languageIds (optional) Идентификаторы ЯПов
 * @param studentGroupId (optional) Идентификатор группы
 * @param status (optional) Статус отбора
 * @param modifiedAtFrom (optional) Время последнего обновления отборов (от)
 * @param modifiedAtTo (optional) Время последнего обновления отборов (до)
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetInterviewListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoInterviewDto | undefined) => Types.PagedListDtoInterviewDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getInterviewList_1Url(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/interview/list?";
if (page === null)
    throw new Error("The parameter 'page' cannot be null.");
else if (page !== undefined)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (size === null)
    throw new Error("The parameter 'size' cannot be null.");
else if (size !== undefined)
    url_ += "size=" + encodeURIComponent("" + size) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInterviewList_1DefaultOptions: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, unknown, Types.PagedListDtoInterviewDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PagedListDtoInterviewDto, unknown, Types.PagedListDtoInterviewDto>, 'queryFn'>> = {
};
export function getGetInterviewList_1DefaultOptions() {
  return getInterviewList_1DefaultOptions;
};
export function setGetInterviewList_1DefaultOptions(options: typeof getInterviewList_1DefaultOptions) {
  getInterviewList_1DefaultOptions = options;
}

export function getInterviewList_1QueryKey(dto: GetInterviewList_1InterviewsQueryParameters): QueryKey;
export function getInterviewList_1QueryKey(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): QueryKey;
export function getInterviewList_1QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { page, size, sort,  } = params[0] as GetInterviewList_1InterviewsQueryParameters;

    return trimArrayEnd([
        'InterviewsClient',
        'getInterviewList_1',
        page as any,
        size as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'InterviewsClient',
        'getInterviewList_1',
        ...params
      ]);
  }
}
export function __getInterviewList_1(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getInterviewList_1(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string[] | undefined,axiosConfig    );
}

export function useGetInterviewList_1Query<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(dto: GetInterviewList_1InterviewsQueryParameters, options?: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Получить список отборов
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function useGetInterviewList_1Query<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, options?: Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetInterviewList_1Query<TSelectData = Types.PagedListDtoInterviewDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let page: any = undefined;
  let size: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ page, size, sort,  } = params[0] as GetInterviewList_1InterviewsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [page, size, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PagedListDtoInterviewDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getInterviewList_1(context, axiosConfig) : __getInterviewList_1,
    queryKey: getInterviewList_1QueryKey(page, size, sort),
    ...getInterviewList_1DefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedListDtoInterviewDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Получить список отборов
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetInterviewList_1Data(queryClient: QueryClient, updater: (data: Types.PagedListDtoInterviewDto | undefined) => Types.PagedListDtoInterviewDto, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined) {
  queryClient.setQueryData(getInterviewList_1QueryKey(page, size, sort),
    updater
  );
}

/**
 * Получить список отборов
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function setGetInterviewList_1DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedListDtoInterviewDto | undefined) => Types.PagedListDtoInterviewDto) {
  queryClient.setQueryData(queryKey, updater);
}