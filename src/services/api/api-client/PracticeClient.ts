//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../api-client.types';
import { getAxios, getBaseUrl } from './helpers';

/**
 * Получение информации о практике студента
 * @param id Id студента
 * @return OK
 */
export function getCurrentStudentPractice(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetCurrentStudentPractice,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetCurrentStudentPractice?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetCurrentStudentPractice(_response);
    });
}

function processGetCurrentStudentPractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Обновление практики
 * @param id Id практики
 * @return OK
 */
export function updatePractice(id: string, body: Types.UpdatePracticeDto, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeUpdatePracticeDto(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdatePractice,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigUpdatePractice?.headers,
            "Content-Type": "application/json",
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdatePractice(_response);
    });
}

function processUpdatePractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Подача заявки на практику студента
 * @return OK
 */
export function createStudentPractice(body: Types.CreatePracticeDto, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeCreatePracticeDto(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateStudentPractice,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreateStudentPractice?.headers,
            "Content-Type": "application/json",
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateStudentPractice(_response);
    });
}

function processCreateStudentPractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Заархивирование практики студента
 * @param id Id практики
 * @return OK
 */
export function archiveStudentPractice(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/archive?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigArchiveStudentPractice,
        ...config,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigArchiveStudentPractice?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processArchiveStudentPractice(_response);
    });
}

function processArchiveStudentPractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Заархивирование практик студентов конкретной группы
 * @param groupId Id группы
 * @return OK
 */
export function archiveStudentPracticesByGroup(groupId: string, config?: AxiosRequestConfig | undefined): Promise<Types.Response> {
    let url_ = getBaseUrl() + "/api/v1/practice/archiveAll?";
      if (groupId === undefined || groupId === null)
        throw new Error("The parameter 'groupId' must be defined and cannot be null.");
      else
        url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigArchiveStudentPracticesByGroup,
        ...config,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigArchiveStudentPracticesByGroup?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processArchiveStudentPracticesByGroup(_response);
    });
}

function processArchiveStudentPracticesByGroup(response: AxiosResponse): Promise<Types.Response> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initResponse(resultData200);
        return Promise.resolve<Types.Response>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Response>(null as any);
}

/**
 * Подтверждение практики студента
 * @param id Id студента
 * @return OK
 */
export function approveStudentPractice(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/approve?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApproveStudentPractice,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigApproveStudentPractice?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApproveStudentPractice(_response);
    });
}

function processApproveStudentPractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Подтверждение практик студентов
 * @param id Id практик
 * @return OK
 */
export function approveStudentPractices(id: string[], config?: AxiosRequestConfig | undefined): Promise<Types.Response> {
    let url_ = getBaseUrl() + "/api/v1/practice/approveMany?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApproveStudentPractices,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigApproveStudentPractices?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApproveStudentPractices(_response);
    });
}

function processApproveStudentPractices(response: AxiosResponse): Promise<Types.Response> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initResponse(resultData200);
        return Promise.resolve<Types.Response>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Response>(null as any);
}

/**
 * Подтверждение практики студентов в компании
 * @param companyId Id компании-партнера
 * @return OK
 */
export function approveStudentPractices_1(companyId: string, config?: AxiosRequestConfig | undefined): Promise<Types.Response> {
    let url_ = getBaseUrl() + "/api/v1/practice/approveAll?";
      if (companyId === undefined || companyId === null)
        throw new Error("The parameter 'companyId' must be defined and cannot be null.");
      else
        url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApproveStudentPractices_1,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigApproveStudentPractices_1?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApproveStudentPractices_1(_response);
    });
}

function processApproveStudentPractices_1(response: AxiosResponse): Promise<Types.Response> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initResponse(resultData200);
        return Promise.resolve<Types.Response>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Response>(null as any);
}

/**
 * Получение информации о практике по id
 * @param practiceId Id практики
 * @return OK
 */
export function getPracticeById(practiceId: string, config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/{practiceId}";
    if (practiceId === undefined || practiceId === null)
      throw new Error("The parameter 'practiceId' must be defined.");
    url_ = url_.replace("{practiceId}", encodeURIComponent("" + practiceId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetPracticeById,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetPracticeById?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetPracticeById(_response);
    });
}

function processGetPracticeById(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Получение информации о практике студентом
 * @return OK
 */
export function getMyPractice(config?: AxiosRequestConfig | undefined): Promise<Types.PracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/my";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetMyPractice,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetMyPractice?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetMyPractice(_response);
    });
}

function processGetMyPractice(response: AxiosResponse): Promise<Types.PracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPracticeDto(resultData200);
        return Promise.resolve<Types.PracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PracticeDto>(null as any);
}

/**
 * Получить список практик студента
 * @param id Id студента
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function getStudentPractices(id: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedPracticesDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/list?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (page === null)
        throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
        url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null)
        throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
        url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (sort === null)
        throw new Error("The parameter 'sort' cannot be null.");
    else if (sort !== undefined)
        sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetStudentPractices,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetStudentPractices?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetStudentPractices(_response);
    });
}

function processGetStudentPractices(response: AxiosResponse): Promise<Types.PagedPracticesDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedPracticesDto(resultData200);
        return Promise.resolve<Types.PagedPracticesDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedPracticesDto>(null as any);
}

/**
 * Получить заявки на практику
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function getPracticeRequests(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedListDtoPracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/list/unapproved?";
    if (page === null)
        throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
        url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null)
        throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
        url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (sort === null)
        throw new Error("The parameter 'sort' cannot be null.");
    else if (sort !== undefined)
        sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetPracticeRequests,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetPracticeRequests?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetPracticeRequests(_response);
    });
}

function processGetPracticeRequests(response: AxiosResponse): Promise<Types.PagedListDtoPracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedListDtoPracticeDto(resultData200);
        return Promise.resolve<Types.PagedListDtoPracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedListDtoPracticeDto>(null as any);
}

/**
 * Получить список практик всех студентов
 * @param studentName (optional) Имя студента
 * @param groupIds (optional) Список идентификаторов групп
 * @param companyId (optional) Идентификатор компании-партнера
 * @param hasReport (optional) Флаг выбора практик с прикрепленным отчетом или без. null - если все
 * @param isReportGraded (optional) Флаг выдачи практик с оцененным отчетом
 * @param isArchived (optional) Флаг выдачи архивных данных
 * @param isPracticeApproved (optional) Флаг подтвержденных практик
 * @param page (optional) Zero-based page index (0..N)
 * @param size (optional) The size of the page to be returned
 * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 * @return OK
 */
export function getAllPractices(studentName?: string | undefined, groupIds?: string[] | undefined, companyId?: string | undefined, hasReport?: boolean | undefined, isReportGraded?: boolean | undefined, isArchived?: boolean | undefined, isPracticeApproved?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedListDtoPracticeDto> {
    let url_ = getBaseUrl() + "/api/v1/practice/list/all?";
    if (studentName === null)
        throw new Error("The parameter 'studentName' cannot be null.");
    else if (studentName !== undefined)
        url_ += "studentName=" + encodeURIComponent("" + studentName) + "&";
    if (groupIds === null)
        throw new Error("The parameter 'groupIds' cannot be null.");
    else if (groupIds !== undefined)
        groupIds && groupIds.forEach(item => { url_ += "groupIds=" + encodeURIComponent("" + item) + "&"; });
    if (companyId === null)
        throw new Error("The parameter 'companyId' cannot be null.");
    else if (companyId !== undefined)
        url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
    if (hasReport === null)
        throw new Error("The parameter 'hasReport' cannot be null.");
    else if (hasReport !== undefined)
        url_ += "hasReport=" + encodeURIComponent("" + hasReport) + "&";
    if (isReportGraded === null)
        throw new Error("The parameter 'isReportGraded' cannot be null.");
    else if (isReportGraded !== undefined)
        url_ += "isReportGraded=" + encodeURIComponent("" + isReportGraded) + "&";
    if (isArchived === null)
        throw new Error("The parameter 'isArchived' cannot be null.");
    else if (isArchived !== undefined)
        url_ += "isArchived=" + encodeURIComponent("" + isArchived) + "&";
    if (isPracticeApproved === null)
        throw new Error("The parameter 'isPracticeApproved' cannot be null.");
    else if (isPracticeApproved !== undefined)
        url_ += "isPracticeApproved=" + encodeURIComponent("" + isPracticeApproved) + "&";
    if (page === null)
        throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
        url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null)
        throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
        url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (sort === null)
        throw new Error("The parameter 'sort' cannot be null.");
    else if (sort !== undefined)
        sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetAllPractices,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetAllPractices?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetAllPractices(_response);
    });
}

function processGetAllPractices(response: AxiosResponse): Promise<Types.PagedListDtoPracticeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedListDtoPracticeDto(resultData200);
        return Promise.resolve<Types.PagedListDtoPracticeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedListDtoPracticeDto>(null as any);
}
let _requestConfigGetCurrentStudentPractice: Partial<AxiosRequestConfig> | null;
export function getGetCurrentStudentPracticeRequestConfig() {
  return _requestConfigGetCurrentStudentPractice;
}
export function setGetCurrentStudentPracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetCurrentStudentPractice = value;
}
export function patchGetCurrentStudentPracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetCurrentStudentPractice = patch(_requestConfigGetCurrentStudentPractice ?? {});
}

let _requestConfigUpdatePractice: Partial<AxiosRequestConfig> | null;
export function getUpdatePracticeRequestConfig() {
  return _requestConfigUpdatePractice;
}
export function setUpdatePracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePractice = value;
}
export function patchUpdatePracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePractice = patch(_requestConfigUpdatePractice ?? {});
}

let _requestConfigCreateStudentPractice: Partial<AxiosRequestConfig> | null;
export function getCreateStudentPracticeRequestConfig() {
  return _requestConfigCreateStudentPractice;
}
export function setCreateStudentPracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateStudentPractice = value;
}
export function patchCreateStudentPracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateStudentPractice = patch(_requestConfigCreateStudentPractice ?? {});
}

let _requestConfigArchiveStudentPractice: Partial<AxiosRequestConfig> | null;
export function getArchiveStudentPracticeRequestConfig() {
  return _requestConfigArchiveStudentPractice;
}
export function setArchiveStudentPracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigArchiveStudentPractice = value;
}
export function patchArchiveStudentPracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigArchiveStudentPractice = patch(_requestConfigArchiveStudentPractice ?? {});
}

let _requestConfigArchiveStudentPracticesByGroup: Partial<AxiosRequestConfig> | null;
export function getArchiveStudentPracticesByGroupRequestConfig() {
  return _requestConfigArchiveStudentPracticesByGroup;
}
export function setArchiveStudentPracticesByGroupRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigArchiveStudentPracticesByGroup = value;
}
export function patchArchiveStudentPracticesByGroupRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigArchiveStudentPracticesByGroup = patch(_requestConfigArchiveStudentPracticesByGroup ?? {});
}

let _requestConfigApproveStudentPractice: Partial<AxiosRequestConfig> | null;
export function getApproveStudentPracticeRequestConfig() {
  return _requestConfigApproveStudentPractice;
}
export function setApproveStudentPracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractice = value;
}
export function patchApproveStudentPracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractice = patch(_requestConfigApproveStudentPractice ?? {});
}

let _requestConfigApproveStudentPractices: Partial<AxiosRequestConfig> | null;
export function getApproveStudentPracticesRequestConfig() {
  return _requestConfigApproveStudentPractices;
}
export function setApproveStudentPracticesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractices = value;
}
export function patchApproveStudentPracticesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractices = patch(_requestConfigApproveStudentPractices ?? {});
}

let _requestConfigApproveStudentPractices_1: Partial<AxiosRequestConfig> | null;
export function getApproveStudentPractices_1RequestConfig() {
  return _requestConfigApproveStudentPractices_1;
}
export function setApproveStudentPractices_1RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractices_1 = value;
}
export function patchApproveStudentPractices_1RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApproveStudentPractices_1 = patch(_requestConfigApproveStudentPractices_1 ?? {});
}

let _requestConfigGetPracticeById: Partial<AxiosRequestConfig> | null;
export function getGetPracticeByIdRequestConfig() {
  return _requestConfigGetPracticeById;
}
export function setGetPracticeByIdRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetPracticeById = value;
}
export function patchGetPracticeByIdRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetPracticeById = patch(_requestConfigGetPracticeById ?? {});
}

let _requestConfigGetMyPractice: Partial<AxiosRequestConfig> | null;
export function getGetMyPracticeRequestConfig() {
  return _requestConfigGetMyPractice;
}
export function setGetMyPracticeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetMyPractice = value;
}
export function patchGetMyPracticeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetMyPractice = patch(_requestConfigGetMyPractice ?? {});
}

let _requestConfigGetStudentPractices: Partial<AxiosRequestConfig> | null;
export function getGetStudentPracticesRequestConfig() {
  return _requestConfigGetStudentPractices;
}
export function setGetStudentPracticesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetStudentPractices = value;
}
export function patchGetStudentPracticesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetStudentPractices = patch(_requestConfigGetStudentPractices ?? {});
}

let _requestConfigGetPracticeRequests: Partial<AxiosRequestConfig> | null;
export function getGetPracticeRequestsRequestConfig() {
  return _requestConfigGetPracticeRequests;
}
export function setGetPracticeRequestsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetPracticeRequests = value;
}
export function patchGetPracticeRequestsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetPracticeRequests = patch(_requestConfigGetPracticeRequests ?? {});
}

let _requestConfigGetAllPractices: Partial<AxiosRequestConfig> | null;
export function getGetAllPracticesRequestConfig() {
  return _requestConfigGetAllPractices;
}
export function setGetAllPracticesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetAllPractices = value;
}
export function patchGetAllPracticesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetAllPractices = patch(_requestConfigGetAllPractices ?? {});
}