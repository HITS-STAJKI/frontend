//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
//@ts-nocheck
import * as Types from '../api-client.types';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../api-client.types';
import { getAxios, getBaseUrl } from './helpers';

/**
 * Получить количество студентов по фильтру
 * @param fullName (optional) ФИО
 * @param isAcadem (optional) Статус нахождения студента в академе
 * @param isGraduated (optional) Статус выпуска студента
 * @param groupIds (optional) Идентификаторы потоков
 * @param companyIds (optional) Идентификаторы компаний-партнеров
 * @param isOnPractice (optional) Находятся на практике/не находятся
 * @param hasPracticeRequest (optional) Наличие заявки на практику
 * @param hasInterviews (optional) Приступили/не приступили к собеседованиям
 * @param stackIds (optional) Идентификаторы стеков
 * @param includeArchived (optional) Включать архивные данные
 * @return OK
 */
export function countStudentsByFilter(fullName?: string | undefined, isAcadem?: boolean | undefined, isGraduated?: boolean | undefined, groupIds?: string[] | undefined, companyIds?: string[] | undefined, isOnPractice?: boolean | undefined, hasPracticeRequest?: boolean | undefined, hasInterviews?: boolean | undefined, stackIds?: string[] | undefined, includeArchived?: boolean | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.StatisticsResponse> {
    let url_ = getBaseUrl() + "/api/v1/statistics/students/count?";
    if (fullName === null)
        throw new Error("The parameter 'fullName' cannot be null.");
    else if (fullName !== undefined)
        url_ += "fullName=" + encodeURIComponent("" + fullName) + "&";
    if (isAcadem === null)
        throw new Error("The parameter 'isAcadem' cannot be null.");
    else if (isAcadem !== undefined)
        url_ += "isAcadem=" + encodeURIComponent("" + isAcadem) + "&";
    if (isGraduated === null)
        throw new Error("The parameter 'isGraduated' cannot be null.");
    else if (isGraduated !== undefined)
        url_ += "isGraduated=" + encodeURIComponent("" + isGraduated) + "&";
    if (groupIds === null)
        throw new Error("The parameter 'groupIds' cannot be null.");
    else if (groupIds !== undefined)
        groupIds && groupIds.forEach(item => { url_ += "groupIds=" + encodeURIComponent("" + item) + "&"; });
    if (companyIds === null)
        throw new Error("The parameter 'companyIds' cannot be null.");
    else if (companyIds !== undefined)
        companyIds && companyIds.forEach(item => { url_ += "companyIds=" + encodeURIComponent("" + item) + "&"; });
    if (isOnPractice === null)
        throw new Error("The parameter 'isOnPractice' cannot be null.");
    else if (isOnPractice !== undefined)
        url_ += "isOnPractice=" + encodeURIComponent("" + isOnPractice) + "&";
    if (hasPracticeRequest === null)
        throw new Error("The parameter 'hasPracticeRequest' cannot be null.");
    else if (hasPracticeRequest !== undefined)
        url_ += "hasPracticeRequest=" + encodeURIComponent("" + hasPracticeRequest) + "&";
    if (hasInterviews === null)
        throw new Error("The parameter 'hasInterviews' cannot be null.");
    else if (hasInterviews !== undefined)
        url_ += "hasInterviews=" + encodeURIComponent("" + hasInterviews) + "&";
    if (stackIds === null)
        throw new Error("The parameter 'stackIds' cannot be null.");
    else if (stackIds !== undefined)
        stackIds && stackIds.forEach(item => { url_ += "stackIds=" + encodeURIComponent("" + item) + "&"; });
    if (includeArchived === null)
        throw new Error("The parameter 'includeArchived' cannot be null.");
    else if (includeArchived !== undefined)
        url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCountStudentsByFilter,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCountStudentsByFilter?.headers,
            "Accept": "*/*",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCountStudentsByFilter(_response);
    });
}

function processCountStudentsByFilter(response: AxiosResponse): Promise<Types.StatisticsResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 409) {
        const _responseText = response.data;
        let result409: any = null;
        let resultData409  = _responseText;
        result409 = Types.initErrorResponse(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initErrorResponse(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 500) {
        const _responseText = response.data;
        let result500: any = null;
        let resultData500  = _responseText;
        result500 = Types.initErrorResponse(resultData500);
        return throwException("Internal Server Error", status, _responseText, _headers, result500);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.initErrorResponse(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.initErrorResponse(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initStatisticsResponse(resultData200);
        return Promise.resolve<Types.StatisticsResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.StatisticsResponse>(null as any);
}
let _requestConfigCountStudentsByFilter: Partial<AxiosRequestConfig> | null;
export function getCountStudentsByFilterRequestConfig() {
  return _requestConfigCountStudentsByFilter;
}
export function setCountStudentsByFilterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCountStudentsByFilter = value;
}
export function patchCountStudentsByFilterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCountStudentsByFilter = patch(_requestConfigCountStudentsByFilter ?? {});
}